#!/usr/bin/env python
# SPDX-License-Identifier: Apache-2.0
# Copyright © 2024 Intel Corporation

from __future__ import annotations
import argparse
import dataclasses
import enum
import sys
import typing as T
import xml.etree.ElementTree as et

from mako.template import Template

if T.TYPE_CHECKING:

    class Arguments(T.Protocol):
        input: str
        header: str
        code: str


HEADER_TEMPLATE = '''\
// Copyright © 2024 Intel Corporation
// SPDX-License-Identifier: Apache-2.0

// This file is autogenerated, do not edit.

#pragma once

#include "exceptions.hpp"
#include "meson/state/state.hpp"
#include "mir.hpp"
#include "passes/private.hpp"

#include <string>
#include <vector>
#include <optional>

namespace MIR::Passes::ArgumentValidator {

% for function in functions:
    struct ${function.struct_name} {
      ## TODO: positional arguments
      % if function.variadic:
        std::vector<MIR::${function.variadic.type.value if function.variadic.convert is None else function.variadic.convert.value}> ${function.variadic.name};
      % endif
      ## TODO: kwargs arguments
    };

    ${function.struct_name}
    parse_${function.name}(const MIR::FunctionCall & func, const State::Persistant & state);

% endfor
} // MIR::Passes::ArgumentValidator

'''

CODE_TEMPLATE = '''\
<%!
    import os
%>
// Copyright © 2024 Intel Corporation
// SPDX-License-Identifier: Apache-2.0

// This file is autogenerated, do not edit.

#include "${os.path.basename(header)}"
#include "passes/argument_extractors.hpp"

namespace MIR::Passes::ArgumentValidator {

namespace {

MIR::File src_to_file(const MIR::Instruction & raw_src, const State::Persistant & pstate,
                      const std::string & subdir, const std::string & name) {
    if (std::holds_alternative<MIR::String>(*raw_src.obj_ptr)) {
        const auto & src = std::get<MIR::String>(*raw_src.obj_ptr);
        return File{src.value, subdir, false, pstate.source_root, pstate.build_root};
    }
    if (std::holds_alternative<MIR::File>(*raw_src.obj_ptr)) {
        return std::get<MIR::File>(*raw_src.obj_ptr);
    }
    throw Util::Exceptions::InvalidArguments{
        "'" + name + "':" + " sources must be strings, files, or custom_target objects."};
}

std::vector<MIR::File>
srcs_to_files(std::vector<MIR::Instruction>::const_iterator begin,
              std::vector<MIR::Instruction>::const_iterator end,
              const FunctionCall & func,
              const State::Persistant & pstate) {
    std::vector<File> files{};
    std::transform(begin, end, std::back_inserter(files),
                   [&](const MIR::Instruction & i) { return src_to_file(i, pstate, func.source_dir, func.name); });
    return files;
}

} // namespace

% for function in functions:
    ${function.struct_name}
    parse_${function.name}(const FunctionCall & func, const State::Persistant & pstate) {
        if (func.pos_args.size() < ${function.min_pos_args}) {
            throw Util::Exceptions::InvalidArguments(
                "${function.name}: Expects ${function.min_pos_args} positional arguments, but received "
                 + std::to_string(func.pos_args.size()));
        }

      % if function.max_pos_args is not None:
        if (func.pos_args.size() > ${function.max_pos_args}) {
            throw Util::Exceptions::InvalidArguments(
                "${function.name}: Expects at least ${function.max_pos_args} positional arguments, but received "
                 + std::to_string(func.pos_args.size()));
        }
      % endif

        // TODO: validate keyword arguments

        auto pos_args = func.pos_args.begin();

        return ${function.struct_name} {
            // TODO: positional arguments
            // TODO: optional arguments
          % if function.variadic:
            .${function.variadic.name} = srcs_to_files(pos_args, func.pos_args.end(), func, pstate),
          % endif
            // TODO: keyword arguments
        };

    }

% endfor
} // MIR::Passes::ArgumentValidator

'''

_T = T.TypeVar('_T')


class ArgumentType(enum.Enum):

    STRING = 'String'
    FILE = 'File'


@dataclasses.dataclass
class VariadicArgument:

    name: str
    type: ArgumentType
    convert: ArgumentType | None


@dataclasses.dataclass
class Function:

    name: str
    variadic: VariadicArgument | None

    @property
    def struct_name(self) -> str:
        return self.name.capitalize()

    @property
    def min_pos_args(self) -> int:
        # Calculate based on min variadic args + number of positional args
        return 0

    @property
    def max_pos_args(self) -> int | None:
        # None is there is no limit
        # Calculate based on variadic arguments + positional arguments, including optional ones
        return None


def extract_attr(e: et.Element | None, attr: str) -> str:
    assert e is not None, 'required element is missing'
    val = e.get(attr)
    assert val is not None, 'required attribute is not set'
    return val


def parse_argument_type(raw: str) -> ArgumentType:
    return ArgumentType[raw.upper()]


def parse_variadic_arguments(element: et.Element | None) -> VariadicArgument | None:
    if element is None:
        return None

    var = element.find('argument')
    assert var is not None, 'variadic argument must have one argument node'

    return VariadicArgument(
        extract_attr(var, 'name'),
        parse_argument_type(extract_attr(var, 'type')),
        parse_argument_type(v) if (v := var.get('convert')) else v,
    )


def parse_xml(xmlfile: str) -> T.Iterator[Function]:
    xml = et.parse(xmlfile)
    for fxml in xml.findall('function'):
        yield Function(
            extract_attr(fxml, 'name'),
            parse_variadic_arguments(fxml.find('./arguments/variadic'))
        )


def main() -> int:
    parser = argparse.ArgumentParser()
    parser.add_argument('input', help='XML description file')
    parser.add_argument('header', help='Where to write the header file')
    parser.add_argument('code', help='Where to write the code file')
    args = T.cast('Arguments', parser.parse_args())

    try:
        description = list(parse_xml(args.input))
        with open(args.header, 'w', encoding='utf-8') as f:
            f.write(Template(HEADER_TEMPLATE).render(functions=description))
        with open(args.code, 'w', encoding='utf-8') as f:
            f.write(Template(CODE_TEMPLATE).render(header=args.header, functions=description))
    except Exception as e:
        print(str(e), file=sys.stderr)
        return 1

    return 0


if __name__ == "__main__":
	sys.exit(main())
